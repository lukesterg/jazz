export const textType = 'text';
export const numberType = 'number';
export const hasOneType = 'hasOne';
export const hasManyType = 'hasMany';

export const meta = Symbol();

const field = (type, typeOptions, userOptions) =>
  Object.assign(
    {
      type,
      primaryKey: false,
      autoGenerated: false,
    },
    typeOptions,
    userOptions || {}
  );

export const text = (userOptions) => field(textType, {}, userOptions);
export const number = (userOptions) => field(numberType, {}, userOptions);
export const hasOne = (relatedModel, userOptions) => field(hasOneType, { relatedModel }, userOptions);
export const hasMany = (relatedModel, userOptions) => field(hasManyType, { relatedModel }, userOptions);

const relatedFieldTypes = [hasOneType, hasManyType];

export const isRelatedField = (field) => relatedFieldTypes.indexOf(field.type) >= 0;

/*
const getRelatedField = (field, models) => {
  const relatedModelName = models.relatedModel;
  const relatedModel = models[relatedModelName];
  const relatedFieldName = field.relatedField;
  const relatedField = relatedModel?.[relatedFieldName];
  if (!relatedField) {
    throw new Error(`unable to find related field "${relatedFieldName}" in model "${relatedModelName}"`);
  }

  return { relatedFieldName, relatedModelName, relatedField };
};*/

const generateRelatedFieldQuery = (fieldNameName, fieldValue, result, queryGenerator) => {
  if (fieldValue.type === 'hasMany') {
    return queryGenerator(fieldValue.relatedModel, fieldValue.relatedField, result.id);
  } else if (fieldValue.type === 'hasOne') {
    return queryGenerator(fieldValue.relatedModel, 'id', result[`${fieldNameName}__id`]);
  } else {
    throw new Error(`unknown field type ${fieldValue.type}`);
  }
};

export const addRelatedFieldsToResult = (modelName, result, models, queryGenerator) => {
  const relatedFields = Object.entries(models[modelName]).filter((field) => isRelatedField(field[1]));
  for (const [relatedFieldName, relatedFieldValue] of relatedFields) {
    const existingValue = result[relatedFieldName];
    if (existingValue) {
      result[`${relatedFieldName}__id`] = existingValue;
    }

    const query = generateRelatedFieldQuery(relatedFieldName, relatedFieldValue, result, queryGenerator);
    const single = relatedFieldValue.type === hasOneType;
    wrapForeignKey(result, relatedFieldName, query, single);
  }
};

const wrapForeignKey = (result, fieldName, query, single) => {
  let queryResult;
  let resultFetched = false;

  const get = () => {
    if (resultFetched) {
      return queryResult;
    }

    resultFetched = true;
    queryResult = single ? query.single() : query.values();
    return queryResult;
  };

  const set = (value) => {
    result = Promise.resolve(value);
    resultFetched = true;
    return value;
  };

  Object.defineProperty(result, fieldName, {
    // if we do a fetch it will be async, so we cannot use properties as would be expected.
    value: (value) => {
      if (value === undefined) {
        return get();
      }

      set(value);
      return value;
    },
    enumerable: false,
  });
};

/*
const verifyPrimaryKey = (fields) => {
  const primaryKey = Object.entries(fields).filter((entry) => entry[1].primaryKey);
  if (primaryKey.length > 1) {
    throw new Error('only one primary key is allowed');
  }

  if (primaryKey.length > 0) {
    fields[meta].primaryKey = primaryKey[0][0];
    return;
  }

  if (fields.id !== undefined) {
    throw new Error('a field called id already exists and is not marked as a primary key');
  }

  fields[meta].primaryKey = 'id';
  fields.id = number({ primaryKey: true, autoGenerated: true });
};

const defaultModelOptions = (options = {}) =>
  Object.assign(
    {
      computedFields: {},
    },
    options
  );

const handleForeignKey = (name, fields, models) => {
  const currentModelRelatedFields = Object.entries(fields).filter(isRelatedField);
  fields[meta].relatedFields = currentModelRelatedFields;
  for (const [currentModelRelatedFieldName, currentModelRelatedField] of currentModelRelatedFields) {
    const { relatedModelName, relatedFieldName } = currentModelRelatedField;
    const relatedField = models[relatedModelName]?.[relatedFieldName];
    if (!relatedField || !isRelatedField(relatedField.type)) {
      throw new Error(
        `field ${currentModelRelatedFieldName} in model ${name} is either invalid or in a one-sided relationship; try adding a relationship back from the model ${relatedModelName}`
      );
    }

    if (relatedField.type === hasManyType && currentModelRelatedField.type === hasManyType) {
      throw new Error(`resolving of many to many relationships are not supported`);
    }
  }
};

const handleModel = (name, fields, models) => {
  verifyPrimaryKey(fields);
  handleForeignKey(name, fields, models);
};

export const createModels = (models, engine) => {
  const modelCopy = Object.fromEntries(
    Object.entries(models).map((entry) => [
      entry[0],
      Object.assign({}, entry[1], {
        [meta]: defaultModelOptions(),
      }),
    ])
  );

  models[meta] = { engine };
  for (const [name, fields] of Object.entries(modelCopy)) {
    handleModel(name, fields, models);
  }

  return modelCopy;
};
*/
