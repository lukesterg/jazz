import { areAllValuesDistinct, throwIfFalsy } from './utilities';

export const textType = 'text';
export const numberType = 'number';
export const hasOneType = 'hasOne';
export const hasManyType = 'hasMany';

export const meta = Symbol();

const field = (type, typeOptions, userOptions) =>
  Object.assign(
    {
      type,
      primaryKey: false,
      autoGenerated: false,
    },
    typeOptions,
    userOptions || {}
  );

export const text = (userOptions) => field(textType, {}, userOptions);
export const number = (userOptions) => field(numberType, {}, userOptions);
export const hasOne = (relatedModel, userOptions) => field(hasOneType, { relatedModel }, userOptions);
export const hasMany = (relatedModel, userOptions) => field(hasManyType, { relatedModel }, userOptions);

const relatedFieldTypes = [hasOneType, hasManyType];

export const isRelatedField = (field) => relatedFieldTypes.indexOf(field.type) >= 0;

export const addRelatedFieldsToResult = (result, models, modelName, connection) => {
  const relatedFields = Object.entries(model[modelName]).filter((field) => isRelatedField(field[1]));
  for (const [relatedFieldName, relatedFieldValue] of relatedFields) {
    const existingValue = result[relatedFieldName];
    if (existingValue !== undefined) {
      result[`${relatedFieldName}__id`] = existingValue;
    }

    Object.defineProperty(result, relatedFieldName, {
      get: () => {
        return ['a'];
      },
    });
  }
};

const verifyPrimaryKey = (fields) => {
  const primaryKey = Object.entries(fields).filter((entry) => entry[1].primaryKey);
  if (primaryKey.length > 1) {
    throw new Error('only one primary key is allowed');
  }

  if (primaryKey.length > 0) {
    fields[meta].primaryKey = primaryKey[0][0];
    return;
  }

  if (fields.id !== undefined) {
    throw new Error('a field called id already exists and is not marked as a primary key');
  }

  fields[meta].primaryKey = 'id';
  fields.id = number({ primaryKey: true, autoGenerated: true });
};

const defaultModelOptions = (options = {}) =>
  Object.assign(
    {
      computedFields: {},
    },
    options
  );

const handleForeignKey = (name, fields, models) => {
  const currentModelRelatedFields = Object.entries(fields).filter(isRelatedField);
  fields[meta].relatedFields = currentModelRelatedFields;
  for (const [currentModelRelatedFieldName, currentModelRelatedField] of currentModelRelatedFields) {
    const { relatedModelName, relatedFieldName } = currentModelRelatedField;
    const relatedField = models[relatedModelName]?.[relatedFieldName];
    if (!relatedField || !isRelatedField(relatedField.type)) {
      throw new Error(
        `field ${currentModelRelatedFieldName} in model ${name} is either invalid or in a one-sided relationship; try adding a relationship back from the model ${relatedModelName}`
      );
    }

    if (relatedField.type === hasManyType && currentModelRelatedField.type === hasManyType) {
      throw new Error(`resolving of many to many relationships are not supported`);
    }
  }
};

const handleModel = (name, fields, models) => {
  verifyPrimaryKey(fields);
  handleForeignKey(name, fields, models);
};

export const createModels = (models, engine) => {
  const modelCopy = Object.fromEntries(
    Object.entries(models).map((entry) => [
      entry[0],
      Object.assign({}, entry[1], {
        [meta]: defaultModelOptions(),
      }),
    ])
  );

  models[meta] = { engine };
  for (const [name, fields] of Object.entries(modelCopy)) {
    handleModel(name, fields, models);
  }

  return modelCopy;
};
