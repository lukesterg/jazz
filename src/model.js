import { areAllValuesDistinct, throwIfFalsy } from './utilities';

export const textType = 'text';
export const numberType = 'number';
export const hasOneType = 'hasOne';
export const hasManyType = 'hasMany';

export const meta = Symbol();

const field = (type, typeOptions, userOptions) =>
  Object.assign(
    {
      type,
      primaryKey: false,
      autoGenerated: false,
    },
    typeOptions,
    userOptions || {}
  );

export const text = (userOptions) => field(textType, {}, userOptions);
export const number = (userOptions) => field(numberType, {}, userOptions);
export const hasOne = (userOptions) => field(hasOneType, {}, userOptions);
export const hasMany = (userOptions) => field(hasManyType, {}, userOptions);

const verifyPrimaryKey = (schema) => {
  const primaryKey = Object.entries(schema).filter((entry) => entry[1].primaryKey);
  if (primaryKey.length > 1) {
    throw new Error('only one primary key is allowed');
  }

  if (primaryKey.length > 0) {
    schema[meta].primaryKey = primaryKey[0][0];
    return;
  }

  if (schema.id !== undefined) {
    throw new Error('a field called id already exists and is not marked as a primary key');
  }

  schema[meta].primaryKey = 'id';
  schema.id = number({ primaryKey: true, autoGenerated: true });
};

const defaultModelOptions = (options = {}) =>
  Object.assign(
    {
      computedFields: {},
    },
    options
  );

const handleRelationships = (() => {
  const getRelatedModel = (models, relationName) => throwIfFalsy(models[relationName]);
  const relationshipTypes = [hasOneType, hasManyType];
  const isARelationshipField = (field) => relationshipTypes.indexOf(field.type) >= 0;
  const getAllRelationshipFields = (model) => Object.entries(model).filter(isARelationshipField);

  return (name, fields, models) => {
    const relationshipFields = getAllRelationshipFields(fields);
    if (!areAllValuesDistinct(relationshipFields.map((field) => field.relationName))) {
      throw new ModelError('can only have one many to many relationship to any particular table');
    }

    for (const [fieldName, fieldValue] of relationshipFields) {
      const { relationName: relatedModelName } = fieldValue;
      const relatedModel = getRelatedModel(relatedModelName);
      ensureNoReverseRelationship(relatedModelName, relatedModel, name);
    }
  };
})();

const handleModel = (models, name, fields) => {
  verifyPrimaryKey(fields);
};

export const createModels = (models) => {
  const modelCopy = Object.fromEntries(
    Object.entries(models).map((entry) => [
      entry[0],
      Object.assign({}, entry[1], {
        [meta]: defaultModelOptions(),
      }),
    ])
  );

  for (const [name, fields] of Object.entries(modelCopy)) {
    handleModel(models, name, fields);
  }

  return modelCopy;
};
